<?php

namespace App\Jobs;

use App\Models\Folder;
use App\Models\Image;
use App\Models\ImageBatch;
use App\Services\ImageProcessingService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class ProcessZipImageJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    // ‚úÖ CONFIGURACI√ìN OPTIMIZADA PARA SERVIDOR POTENTE
    public $timeout = 900;      // ‚úÖ 15 minutos por imagen (era 10)
    public $tries = 3;          // ‚úÖ M√°s reintentos (era 2)
    public $maxExceptions = 3;

    // ‚úÖ Backoff optimizado
    public function backoff(): array
    {
        return [30, 120, 300]; // 30s, 2min, 5min
    }

    public function __construct(
        public int $projectId,
        public array $asignacion,
        public string $tempPath,
        public int $batchId
    ) {}

    public function handle()
    {
        $startTime = microtime(true);
        $attemptNumber = $this->attempts();

        Log::info("üöÄ [INTENTO {$attemptNumber}] ProcessZipImageJob iniciado", [
            'batch_id' => $this->batchId,
            'project_id' => $this->projectId,
            'imagen' => $this->asignacion['imagen'] ?? 'N/A',
            'modulo' => $this->asignacion['modulo'] ?? 'N/A',
            'temp_path' => $this->tempPath,
            'memory_start' => memory_get_usage(true) / 1024 / 1024 . 'MB'
        ]);

        $batch = ImageBatch::find($this->batchId);
        if (!$batch) {
            Log::error("‚ùå Batch no encontrado: {$this->batchId}");
            return;
        }

        // ‚úÖ VERIFICAR SI EL BATCH FUE CANCELADO
        if (in_array($batch->status, ['failed', 'cancelled'])) {
            Log::info("‚ÑπÔ∏è Job cancelado - batch en estado: {$batch->status}");
            return;
        }

        try {
            // ‚úÖ VALIDACI√ìN PREVIA OPTIMIZADA
            $validation = $this->validateAssignment();
            if (!$validation['valid']) {
                $this->incrementError($batch, $validation['error']);
                return;
            }

            ['nombreImagen' => $nombreImagen, 'moduloPath' => $moduloPath] = $validation;

            // ‚úÖ BUSCAR ARCHIVO EXTRA√çDO CON MEJOR ALGORITMO
            $extractedFile = $this->findExtractedFile($nombreImagen);
            if (!$extractedFile) {
                $this->incrementError($batch, "Archivo no encontrado: {$nombreImagen}");
                return;
            }

            // ‚úÖ BUSCAR FOLDER CON CACHE
            $folder = $this->findFolder($moduloPath);
            if (!$folder) {
                $this->incrementError($batch, "M√≥dulo no encontrado: {$moduloPath}");
                return;
            }

            // ‚úÖ PROCESAR IMAGEN
            $success = $this->processImageForFolder($folder, $extractedFile, $nombreImagen, $batch);

            $processingTime = round(microtime(true) - $startTime, 2);

            if ($success) {
                Log::info("‚úÖ [√âXITO] Imagen procesada correctamente", [
                    'image_name' => $nombreImagen,
                    'folder_id' => $folder->id,
                    'processing_time' => $processingTime . 's',
                    'memory_peak' => memory_get_peak_usage(true) / 1024 / 1024 . 'MB'
                ]);
            } else {
                $this->incrementError($batch, "Error procesando {$nombreImagen}");
            }

        } catch (\Throwable $e) {
            $processingTime = round(microtime(true) - $startTime, 2);

            Log::error("‚ùå [ERROR] ProcessZipImageJob fall√≥", [
                'batch_id' => $this->batchId,
                'error' => $e->getMessage(),
                'processing_time' => $processingTime . 's',
                'attempt' => $attemptNumber,
                'memory_peak' => memory_get_peak_usage(true) / 1024 / 1024 . 'MB'
            ]);

            $this->incrementError($batch, "Error procesando: " . $e->getMessage());
        }
    }

    /**
     * ‚úÖ VALIDACI√ìN OPTIMIZADA DE ASIGNACI√ìN
     */
    private function validateAssignment(): array
    {
        if (!isset($this->asignacion['imagen']) || !isset($this->asignacion['modulo'])) {
            return [
                'valid' => false,
                'error' => 'Asignaci√≥n incompleta: faltan campos imagen o modulo'
            ];
        }

        $nombreImagen = basename($this->asignacion['imagen']);
        $moduloPath = trim($this->asignacion['modulo']);

        if (empty($nombreImagen) || empty($moduloPath)) {
            return [
                'valid' => false,
                'error' => 'Nombre de imagen o ruta de m√≥dulo vac√≠os'
            ];
        }

        // ‚úÖ VALIDAR EXTENSI√ìN
        $extension = strtolower(pathinfo($nombreImagen, PATHINFO_EXTENSION));
        $validExtensions = ['jpg', 'jpeg', 'png', 'bmp', 'tiff', 'webp'];

        if (!in_array($extension, $validExtensions)) {
            return [
                'valid' => false,
                'error' => "Extensi√≥n no v√°lida: {$extension}"
            ];
        }

        return [
            'valid' => true,
            'nombreImagen' => $nombreImagen,
            'moduloPath' => $moduloPath,
            'extension' => $extension
        ];
    }

    /**
     * ‚úÖ B√öSQUEDA OPTIMIZADA DE ARCHIVO EXTRA√çDO
     */
    private function findExtractedFile(string $nombreImagen): ?string
    {
        if (!is_dir($this->tempPath)) {
            Log::error("‚ùå Directorio temporal no existe: {$this->tempPath}");
            return null;
        }

        // ‚úÖ B√öSQUEDA RECURSIVA OPTIMIZADA
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($this->tempPath, \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $filename = $file->getFilename();

                // ‚úÖ COMPARACI√ìN CASE-INSENSITIVE
                if (strtolower($filename) === strtolower($nombreImagen)) {
                    $filePath = $file->getPathname();

                    // ‚úÖ VERIFICAR QUE EL ARCHIVO ES ACCESIBLE
                    if (is_readable($filePath) && filesize($filePath) > 0) {
                        Log::debug("‚úÖ Archivo encontrado: {$filePath}");
                        return $filePath;
                    }
                }
            }
        }

        // ‚úÖ B√öSQUEDA ALTERNATIVA SIN EXTENSI√ìN
        $nameWithoutExt = pathinfo($nombreImagen, PATHINFO_FILENAME);
        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $fileNameWithoutExt = pathinfo($file->getFilename(), PATHINFO_FILENAME);

                if (strtolower($fileNameWithoutExt) === strtolower($nameWithoutExt)) {
                    $filePath = $file->getPathname();

                    if (is_readable($filePath) && filesize($filePath) > 0) {
                        Log::debug("‚úÖ Archivo encontrado por nombre base: {$filePath}");
                        return $filePath;
                    }
                }
            }
        }

        Log::warning("‚ö†Ô∏è Archivo no encontrado: {$nombreImagen} en {$this->tempPath}");
        return null;
    }

    /**
     * ‚úÖ B√öSQUEDA OPTIMIZADA DE FOLDER CON CACHE
     */
    private function findFolder(string $moduloPath): ?Folder
    {
        // ‚úÖ CACHE EST√ÅTICO PARA B√öSQUEDAS REPETIDAS
        static $folderCache = [];
        $cacheKey = "{$this->projectId}:{$moduloPath}";

        if (isset($folderCache[$cacheKey])) {
            return $folderCache[$cacheKey];
        }

        // ‚úÖ B√öSQUEDA OPTIMIZADA POR FULL_PATH
        $folder = Folder::where('project_id', $this->projectId)
            ->where('full_path', $moduloPath)
            ->first();

        if (!$folder) {
            // ‚úÖ B√öSQUEDA ALTERNATIVA POR NOMBRE
            $folder = Folder::where('project_id', $this->projectId)
                ->where('name', $moduloPath)
                ->first();
        }

        // ‚úÖ GUARDAR EN CACHE
        $folderCache[$cacheKey] = $folder;

        if ($folder) {
            Log::debug("‚úÖ Folder encontrado: ID {$folder->id}, Nombre: {$folder->name}");
        } else {
            Log::warning("‚ö†Ô∏è Folder no encontrado: {$moduloPath}");
        }

        return $folder;
    }

    /**
     * ‚úÖ PROCESAMIENTO OPTIMIZADO DE IMAGEN
     */
    private function processImageForFolder(Folder $folder, string $extractedFile, string $nombreImagen, ImageBatch $batch): bool
    {
        try {
            // ‚úÖ LIMPIEZA OPTIMIZADA DE IM√ÅGENES EXISTENTES
            $this->cleanupExistingImages($folder);

            // ‚úÖ SUBIDA OPTIMIZADA A WASABI
            $wasabiPath = $this->uploadToWasabi($extractedFile, $nombreImagen);
            if (!$wasabiPath) {
                return false;
            }

            // ‚úÖ CREACI√ìN DE IMAGEN EN BD
            $image = $this->createImageRecord($folder, $wasabiPath);
            if (!$image) {
                return false;
            }

            // ‚úÖ PROCESAMIENTO CON SERVICE
            $processed = $this->processWithService($image);
            if (!$processed) {
                return false;
            }

            // ‚úÖ VERIFICACI√ìN DE √âXITO Y ACTUALIZACI√ìN DE BATCH
            $success = $this->validateProcessingSuccess($processed, $image);
            if ($success) {
                $this->updateBatchProgress($batch);
            }

            return $success;

        } catch (\Throwable $e) {
            Log::error("‚ùå Error procesando imagen {$nombreImagen}: " . $e->getMessage());
            return false;
        }
    }

    /**
     * ‚úÖ LIMPIEZA OPTIMIZADA DE IM√ÅGENES EXISTENTES
     */
    private function cleanupExistingImages(Folder $folder): void
    {
        $existingImages = $folder->images;
        if ($existingImages->isEmpty()) {
            return;
        }

        Log::debug("üßπ Limpiando {$existingImages->count()} im√°genes existentes del folder {$folder->id}");

        foreach ($existingImages as $existing) {
            try {
                // ‚úÖ ELIMINAR DE WASABI
                if ($existing->original_path && Storage::disk('wasabi')->exists($existing->original_path)) {
                    Storage::disk('wasabi')->delete($existing->original_path);
                }

                // ‚úÖ ELIMINAR RELACIONES
                $existing->processedImage?->delete();
                $existing->analysisResult?->delete();
                $existing->delete();

            } catch (\Exception $e) {
                Log::warning("‚ö†Ô∏è Error limpiando imagen existente {$existing->id}: " . $e->getMessage());
            }
        }
    }

    /**
     * ‚úÖ SUBIDA OPTIMIZADA A WASABI
     */
    private function uploadToWasabi(string $extractedFile, string $nombreImagen): ?string
    {
        try {
            $imageContent = file_get_contents($extractedFile);
            if ($imageContent === false) {
                throw new \Exception("No se pudo leer el archivo");
            }

            $wasabiPath = "projects/{$this->projectId}/images/{$nombreImagen}";

            Log::debug("üì§ Subiendo a Wasabi", [
                'wasabi_path' => $wasabiPath,
                'image_size' => strlen($imageContent) / 1024 . 'KB'
            ]);

            $success = Storage::disk('wasabi')->put($wasabiPath, $imageContent);
            if (!$success) {
                throw new \Exception("Fall√≥ la subida a Wasabi");
            }

            // ‚úÖ VERIFICAR QUE SE SUBI√ì CORRECTAMENTE
            if (!Storage::disk('wasabi')->exists($wasabiPath)) {
                throw new \Exception("Archivo no encontrado en Wasabi despu√©s de la subida");
            }

            return $wasabiPath;

        } catch (\Exception $e) {
            Log::error("‚ùå Error subiendo a Wasabi: " . $e->getMessage());
            return null;
        }
    }

    /**
     * ‚úÖ CREACI√ìN OPTIMIZADA DE REGISTRO DE IMAGEN
     */
    private function createImageRecord(Folder $folder, string $wasabiPath): ?Image
    {
        try {
            $image = Image::create([
                'folder_id' => $folder->id,
                'original_path' => $wasabiPath,
                'status' => 'uploaded',
                'is_counted' => false,
            ]);

            Log::debug("‚úÖ Imagen creada en BD: ID {$image->id}");
            return $image;

        } catch (\Exception $e) {
            Log::error("‚ùå Error creando imagen en BD: " . $e->getMessage());
            return null;
        }
    }

    /**
     * ‚úÖ PROCESAMIENTO CON SERVICE OPTIMIZADO
     */
    private function processWithService(Image $image): ?\App\Models\Image
    {
        try {
            $service = app(ImageProcessingService::class);
            $processed = $service->process($image, $this->batchId);

            if (!$processed) {
                Log::warning("‚ö†Ô∏è ImageProcessingService retorn√≥ null para imagen {$image->id}");
                return null;
            }

            Log::debug("‚úÖ Imagen procesada con service", [
                'image_id' => $image->id,
                'status' => $processed->status ?? 'unknown',
                'has_processed_image' => $processed->processedImage !== null
            ]);

            return $processed;

        } catch (\Exception $e) {
            Log::error("‚ùå Error en ImageProcessingService: " . $e->getMessage());
            return null;
        }
    }

    /**
     * ‚úÖ VALIDACI√ìN DE √âXITO DE PROCESAMIENTO
     */
    private function validateProcessingSuccess(\App\Models\Image $processed, Image $originalImage): bool
    {
        // ‚úÖ VERIFICAR M√öLTIPLES CONDICIONES DE √âXITO
        $hasProcessedImage = $processed->processedImage && $processed->processedImage->corrected_path;
        $statusIsProcessed = $processed->status === 'processed';
        $statusIsNotError = $processed->status !== 'error';

        $isSuccessful = $hasProcessedImage || $statusIsProcessed || $statusIsNotError;

        if ($isSuccessful) {
            Log::debug("‚úÖ Procesamiento exitoso", [
                'image_id' => $processed->id,
                'has_corrected_path' => $hasProcessedImage,
                'status' => $processed->status,
                'processing_method' => $processed->analysisResult?->processing_method ?? 'unknown'
            ]);
        } else {
            Log::warning("‚ö†Ô∏è Procesamiento no exitoso", [
                'image_id' => $processed->id,
                'status' => $processed->status,
                'has_processed_image' => $processed->processedImage !== null,
                'has_corrected_path' => $hasProcessedImage
            ]);
        }

        return $isSuccessful;
    }

    /**
     * ‚úÖ ACTUALIZACI√ìN THREAD-SAFE DEL BATCH
     */
    private function updateBatchProgress(ImageBatch $batch): void
    {
        try {
            \DB::transaction(function() use ($batch) {
                // ‚úÖ MARCAR IMAGEN COMO CONTADA
                $batch->increment('processed');
                $batch->touch();
            });

            $currentProgress = $batch->fresh();
            $progressPercent = $currentProgress->total > 0
                ? round(($currentProgress->processed / $currentProgress->total) * 100, 1)
                : 0;

            // ‚úÖ LOG DE PROGRESO CADA 50 IM√ÅGENES
            if ($currentProgress->processed % 50 === 0) {
                Log::info("üìä Progreso batch {$batch->id}: {$currentProgress->processed}/{$currentProgress->total} ({$progressPercent}%)");
            }

        } catch (\Exception $e) {
            Log::warning("‚ö†Ô∏è Error actualizando progreso batch: " . $e->getMessage());
        }
    }

    /**
     * ‚úÖ MANEJO OPTIMIZADO DE ERRORES
     */
    private function incrementError(ImageBatch $batch, string $message): void
    {
        Log::error("‚ùå Error en ProcessZipImageJob: {$message}", [
            'batch_id' => $this->batchId,
            'attempt' => $this->attempts()
        ]);

        try {
            \DB::transaction(function() use ($batch, $message) {
                $batch->increment('errors');

                // ‚úÖ MANTENER HIST√ìRICO DE ERRORES LIMITADO
                $errors = $batch->error_messages ?? [];
                $errors[] = [
                    'message' => $message,
                    'timestamp' => now()->toISOString(),
                    'attempt' => $this->attempts()
                ];

                // ‚úÖ MANTENER SOLO LOS √öLTIMOS 100 ERRORES
                $batch->update([
                    'error_messages' => array_slice($errors, -100),
                    'updated_at' => now()
                ]);
            });

        } catch (\Exception $e) {
            Log::error("Error actualizando errores en batch: " . $e->getMessage());
        }
    }

    /**
     * ‚úÖ MANEJO DE FALLOS DEFINITIVOS
     */
    public function failed(\Throwable $e): void
    {
        Log::error("‚ùå ProcessZipImageJob FAILED definitivamente", [
            'batch_id' => $this->batchId,
            'project_id' => $this->projectId,
            'image' => $this->asignacion['imagen'] ?? 'unknown',
            'error' => $e->getMessage(),
            'attempts' => $this->attempts(),
            'memory_peak' => memory_get_peak_usage(true) / 1024 / 1024 . 'MB'
        ]);

        $batch = ImageBatch::find($this->batchId);
        if ($batch) {
            $this->incrementError($batch, "Job failed definitivamente: " . $e->getMessage());

            // ‚úÖ VERIFICAR SI EL BATCH TIENE DEMASIADOS ERRORES
            $errorRate = $batch->errors / max($batch->total, 1);
            if ($errorRate > 0.5) { // 50% de error m√°ximo
                Log::critical("üíÄ Batch {$batch->id} con demasiados errores ({$errorRate}%), marcando como fallido");
                $batch->update(['status' => 'failed']);
            }
        }
    }
}
